# coding: utf-8
{{>partial_header}}
from __future__ import absolute_import

try:
    from enum import Enum, EnumMeta
except ImportError:
    from enum34 import Enum, EnumMeta
import click
import decorator
from functools import wraps

from {{packageName}} import *


class State(object):
    def __init__(self, api=None, format=None{{# cliStateParams }}, {{paramName}}=None{{/ cliStateParams }}):
        self.api = api
        self.format = format
{{# cliStateParams }}
        self.{{paramName}} = {{paramName}}
{{/ cliStateParams }}


pass_state = click.make_pass_decorator(State)



def get_or_push(fun):
    @pass_state
    @click.pass_context
    @wraps(fun)
    def decorated(click_context, state, *args, **kwargs):
        for attr in kwargs:
            setattr(state, attr, kwargs[attr])
        try:
            current_obj = fun(*args, **kwargs)
        except:
            current_obj = fun(state, *args, **kwargs)
        if click_context.invoked_subcommand is None:
            print(current_obj)
        else:
            click_context.obj = current_obj

    return decorated


def object_print(fun):
    def object_print_decorator(fun, *args, **kwargs):
        obj = fun(*args, **kwargs)
        print(obj)

    return decorator.decorate(fun, object_print_decorator)


def add_typed_subcommands(type_):
    def add_fun(fun, attribute_name):
        @fun.command(name=attribute_name)
        @click.make_pass_decorator(type_)
        def type_cmd(obj):
            print(getattr(obj, attribute_name))

    def decorator(fun):
        for attribute_name, attribute_type in type_.openapi_types.items():
            add_fun(fun, attribute_name)

        setattr(fun, 'invoke_without_command', True)

        return fun

    return decorator


def typedCommaArrayType(type_):
    class CommaArrayType(click.ParamType):
        name = 'comma-separated-%s' % type_

        def convert(self, value, param, ctx):
            try:
                return [type_(val) for val in value.split(',')]
            except ValueError:
                self.fail('%s is not a valid list of %s' % (value, type_), param, ctx)

    return CommaArrayType()


def typed_command_parameter(param_name, type_):
    def decorator(fun):
        current = fun

        for option in list_arguments(param_name, type_, []):
            current = option(current)

        return current

    def str_to_class(klass):
        # convert str to class
        if klass in ApiClient.NATIVE_TYPES_MAPPING:
            return ApiClient.NATIVE_TYPES_MAPPING[klass]
        else:
            return getattr(petstore.models, klass)

    def list_arguments(current_param_name, this_type, current_list):
        for attribute_name, attribute_type in this_type.openapi_types.items():

            arguments = []

            if attribute_type.startswith('list['):
                sub_klass = re.match('list\[(.*)\]', attribute_type).group(1)
                arguments.append(click.option('--%s_%s' % (current_param_name, attribute_name), type=sub_klass, multiple=True))
            else:
                klass = str_to_class(attribute_type)
                if klass in ApiClient.PRIMITIVE_TYPES:
                    arguments.append(click.option('--%s_%s' % (current_param_name, attribute_name), type=klass))
                else:
                    child_arguments = list_arguments(current_param_name + "_" + attribute_name, klass, [])
                    arguments.extend(child_arguments)

            current_list.extend(arguments)
        return current_list

    return decorator


@click.group()
@click.pass_context
def main(ctx):
    configuration = Configuration()
    ctx.obj = State(format=format, api={{classname}}(configuration))


{{# cliCommands }}
# {{{ this }}} # noqa: 501
    {{# name }}
    {{# operation }}
        {{#returnType}}
            {{^returnTypeIsPrimitive}}
                {{^ isListContainer }}
@add_typed_subcommands({{returnType}})
                {{/ isListContainer }}
            {{/returnTypeIsPrimitive}}
        {{/returnType}}
    {{/operation}}
    {{# isGroup }}
@{{{parent.fullName}}}.group(name="{{ cliName }}")
    {{/ isGroup }}
    {{^ isGroup }}
@{{{parent.fullName}}}.command(name="{{ cliName }}")
@object_print
    {{/ isGroup }}
    {{# isSelectorGroup }}
        {{# operation }}
            {{# pathParams }}
@click.argument("{{paramName}}", type={{dataType}})
        {{/pathParams}}
        {{/ operation }}
@get_or_push
    {{/isSelectorGroup}}
    {{# operation }}
        {{# queryParams }}
            {{> cli_param }}
        {{/ queryParams }}
        {{# bodyParams }}
            {{> cli_param }}
        {{/bodyParams}}
@pass_state
def {{fullName}}(state{{#queryParams}}, {{paramName}}{{/queryParams}}{{#selectorParams}}, {{paramName}}{{/selectorParams}}):
    # {{httpMethod}} {{path}}
        {{# headerParams }}
    {{paramName}}=state.{{paramName}}
        {{/headerParams}}
        {{# pathParams }}
    {{paramName}}=state.{{paramName}}
        {{/pathParams}}
    return state.api.{{operationIdLowerCase}}({{#allParams}}{{paramName}}{{# hasMore }}, {{/hasMore}}{{/allParams}})
    {{/operation}}
    {{^ operation }}
def {{fullName}}():
    pass
    {{/ operation }}


    {{/name}}
{{/ cliCommands }}
if __name__ == '__main__':
    main()